<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Tool</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Tool.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Tool.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">SAT-Pol-0.1.0.0</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Tool</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module aims to provide an efficient tool to solve the SAT
 problem. Both the algorithm and the implementation have been carried out by
 the researchers from the department of Computer Science and Artificial
 Intelligence at the University of Seville.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:tool">tool</a> :: (<a href="../base-4.9.1.0/Data-Eq.html#t:Eq">Eq</a> u, <a href="../base-4.9.1.0/Text-Show.html#t:Show">Show</a> (m u), <a href="../base-4.9.1.0/Text-Show.html#t:Show">Show</a> u, MonomialConstructor m, Algebra k (m u), <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> (m u), <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> k, <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> k) =&gt; [Vect k (m u)] -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:varsList">varsList</a> :: (<a href="../base-4.9.1.0/Data-Foldable.html#t:Foldable">Foldable</a> t, <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> k, MonomialConstructor m, <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> (m v), <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> k) =&gt; t (Vect k (m v)) -&gt; [Vect k (m v)]</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:tool" class="def">tool</a> :: (<a href="../base-4.9.1.0/Data-Eq.html#t:Eq">Eq</a> u, <a href="../base-4.9.1.0/Text-Show.html#t:Show">Show</a> (m u), <a href="../base-4.9.1.0/Text-Show.html#t:Show">Show</a> u, MonomialConstructor m, Algebra k (m u), <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> (m u), <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> k, <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> k) =&gt; [Vect k (m u)] -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Tool.html#tool" class="link">Source</a> <a href="#v:tool" class="selflink">#</a></p><div class="doc"><p>tool decides if the set of formulas that produced the set of polynomials
 were satisfiables. The function input is a list of polynomials because the
 transformation from formula to polynomial is handled by ReadingF.hs module.</p></div></div><div class="top"><p class="src"><a id="v:varsList" class="def">varsList</a> :: (<a href="../base-4.9.1.0/Data-Foldable.html#t:Foldable">Foldable</a> t, <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> k, MonomialConstructor m, <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> (m v), <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> k) =&gt; t (Vect k (m v)) -&gt; [Vect k (m v)] <a href="src/Tool.html#varsList" class="link">Source</a> <a href="#v:varsList" class="selflink">#</a></p><div class="doc"><p>varsList xs return the set of variables which occurs in any polynomial of
 the list xs. For example, the trivial case:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let xs = (take 10 (map (var . (\n -&gt; 'x':n) . show) [1..])) :: [LexPoly F2 String]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>xs
</code></strong>[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>varsList xs
</code></strong>[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>varsList [x1*x2+x2,x1+x1*x3,x1*x4*x2]
</code></strong>[x1,x2,x3,x4]
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>